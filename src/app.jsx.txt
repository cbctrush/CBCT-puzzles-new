import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, signInWithCustomToken } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, onSnapshot } from 'firebase/firestore';

// --- CONFIGURATION ---
const FREE_QUESTION_COUNT = 2; // Sets the number of free questions available to non-subscribers

// --- THEME COLORS: OCEANIC (Blue/Teal) ---
// Main UI (Header, Primary Buttons)
const COLOR_PRIMARY = 'bg-blue-700';
const COLOR_PRIMARY_HOVER = 'hover:bg-blue-800';
const COLOR_PRIMARY_TEXT = 'text-white';
// Accent/Success (Correct Answer, Progress Bar)
const COLOR_ACCENT = 'bg-teal-500';
const COLOR_ACCENT_HOVER = 'hover:bg-teal-600';
const COLOR_ACCENT_TEXT = 'text-gray-900';
// Error/Warning (Incorrect Answer, End Quiz)
const COLOR_ERROR = 'bg-red-500';


// --- QUIZ DATA ---
// NOTE: The "category" field MUST be an array [] to allow for multiple categories.
const quizData = [
  {
    "question": "What dental anomaly is shown in the images?",
    "options": ["Dens in-dente (dens invaginatus)", "Dens evaginatus", "Interal root resorption", "None of the above"],
    "answer": "Dens in-dente (dens invaginatus)",
    "images": [
      "https://i.imgur.com/4YRHvHr.jpeg",
      "https://i.imgur.com/rEThN73.jpeg",
    ],
    "explanation": "DENS IN DENTE refers to dens invaginatus, a rare developmental anomaly where the tooth's enamel folds inward during formation, creating a deep invagination or cavity that can resemble a 'tooth within a tooth'",
    "answerImage": "https://i.imgur.com/dnyhyCk.jpeg",
    "category": ["Anatomy", "Diagnostics"]
  },
  {
    "question": "True or false: the radiolucent area at the apex of this fused Mesiobuccal-Palatal root can be caused by an untreated canal.",
    "options": ["True", "False"],
    "answer": "True",
    "images": [
      "https://i.imgur.com/pv5yCxx.jpeg"
    ],
    "explanation": "Although we cannot distinctly see a dark line suggestive of a canal, there could be an untreated canal located between the MB and P canal. This was the case here; a few months after treating that canal only, the radiolucent area cleared and the apex appeard normal.",
    "answerImage": "https://i.imgur.com/WrD9dvJ.jpeg",
    "category": ["Anatomy"]
  },
  {
    "question": "A vertical root fracture on an endodontically treated typically occurs:",
    "options": ["On the buccal or lingual of the root", "On the mesial or distal of the root"],
    "answer": "On the buccal or lingual of the root",
    "images": [
      "https://i.imgur.com/pi7l4xG.jpeg",
      "https://i.imgur.com/4mqC45e.jpeg"
    ],
    "explanation": "The typical pattern for a vertical root fracture in an endodontivcally treated tooth is a longitudinal fracture located on the bucal or lingual (or both)",
    "answerImage": null,
    "category": ["Fractures"]
  },
  {
    "question": "Here is a sagittal slice through the distal root of a lower second molar. The yellow arrow is on the:",
    "options": ["Buccal aspect of the mandible", "Lingual aspect of the mandible"],
    "answer": "Lingual aspect of the mandible",
    "images": [
      "https://i.imgur.com/YLAqdnO.jpeg"
    ],
    "explanation": "We know that around the level of the mabibular second molar, there is lingual concavity in the body of the mandible, making the lingual cortex very thin, and the buccal cortex at that level is usually much thicker (opposite side of the arrow)",
    "answerImage": null,
    "category": ["CBCT Basics", "Anatomy"]
  },
  {
    "question": "Here is an axial slice through the maxillary posterior teeth. The arrow is pointing to the MB root of the first molar. We can confidently say that there is no MB2 canal present inside that root.",
    "options": ["True", "False"],
    "answer": "False",
    "images": [
      "https://i.imgur.com/CLNt9pL.jpeg"
    ],
    "explanation": "Most of the time, the MB2 canal is too small to detect on the images. However, the fact that the root is oval and the MB1 canal is off-centered towards the buccal is highly suggestive of the presence of an MB2. This was the case here. The MB root was retreated an the patient's symptoms and infection resolved.",
    "answerImage": "https://i.imgur.com/P7x9r0Z.jpeg",
    "category": ["Anatomy", "Endodontics"]
  },
  {
    "question": "An additional disto-lingual root on a lower molar (usually first molar) is know as what?",
    "options": ["Radix Entomolaris", "Radix Paramolaris"],
    "answer": "Radix Entomolaris",
    "images": [
      "https://i.imgur.com/gDPxhzp.png",
      "https://i.imgur.com/LBJzPsh.png",
    ],
    "explanation": "Radix entomolaris is a significant anatomical variation where a mandibular first molar has an additional, extra root located distolingually ",
    "answerImage": "https://i.imgur.com/hrgV5ru.jpeg",
    "category": ["Anatomy"]
  },
  {
    "question": "The small radiolucency visible on an axial slice, located on the distal of this second molar is probably due to:",
    "options": ["Generalized periodontal disease", "A vertical root fracture", "A crack on the distal wall extending below the bone level", "None of the above"],
    "answer": "A crack on the distal wall extending below the bone level",
    "images": [
      "https://i.imgur.com/BOWYxcT.jpeg",
    ],
    "explanation": "A crack on the distal marginal ridge, which has progressed apically, below the crestal bone tends to create a very small and narrow area of localized bone loss adjacent to the crack. The crack itself is usually too small to be detected by the imaging.",
    "answerImage": "https://i.imgur.com/T1GKBka.jpeg",
    "category": ["Fractures"]
  },
  {
    "question": "The yellow arrow is pointing to an area of :",
    "options": ["Inflammatory root resorption", "External cervical resorption", "Internal root resorption", "None of the above"],
    "answer": "External cervical resorption",
    "images": [
      "https://i.imgur.com/fTXsjay.jpeg",
      "https://i.imgur.com/TUJ0Ex3.jpeg",
    ],
    "explanation": "This was a strange tooth, which had all three types of resorption. External cervical resorption starts at the level of the connective tissue attachment and progresses  inside the dentin, but typically does not involve the pulp because of the protective nature of the predentin.",
    "answerImage": "https://i.imgur.com/xI5xzPY.jpeg",
    "category": ["Resorption"]
  },
  {
    "question": "The radiolucent area, as pointed out by the yellow arrows and suggestive of crestal bone loss on the palatal and mesial aspect of the upper first molar is more likely due to:",
    "options": ["A primary periodontal problem", "A crack or fracture or the tooth or root"],
    "answer": "A primary periodontal problem",
    "images": [
      "https://i.imgur.com/q3UAAf3.jpeg",
    ],
    "explanation": "Fractures and crack typically produce a very narrow and localized area of bone loss adjacent to the site of the fracture. However, here the radiolucent area is quite extensive. Teeth that have not had root canals also tend to crack on the mesial or distal wall. Of course, a clinical exam is needed to correlate these findings.",
    "answerImage": null,
    "category": ["Diagnostics"]
  },
  {
    "question": "The yellow arrow points to :",
    "options": ["An endodontic infection", "A normal anatomical structure"],
    "answer": "A normal anatomical structure",
    "images": [
      "https://i.imgur.com/GjChvnu.jpeg",
    ],
    "explanation": "This is an axial slice going through the apices of the maxillary anterior teeth. The radilucent area is coonsistent with the nasopalatine duct.",
    "answerImage": null,
    "category": ["Diagnostics", "Anatomy"] // Corrected: ensures Diagnostics and Anatomy are separate categories.
  },
  // --- NEW QUESTIONS FROM ARTICLE ---
  {
    "question": "What is the primary factor that reduces the sensitivity and specificity of CBCT in detecting Vertical Root Fractures (VRFs) in endodontically treated teeth?",
    "options": ["The need for surgical confirmation (gold standard)", "The fracture being too large to fit the limited FOV", "Artifacts from high-density materials like gutta-percha or metal posts", "The inability to distinguish between a crack and a craze line"],
    "answer": "Artifacts from high-density materials like gutta-percha or metal posts",
    "images": [],
    "explanation": "High-density materials like gutta-percha and metal posts cause star-shaped streak artifacts and scatter/beam hardening. These artifacts can mimic or obscure fracture lines, significantly reducing the diagnostic accuracy of the CBCT scan for VRFs.",
    "answerImage": null,
    "category": ["Fractures", "CBCT Basics"]
  },
  {
    "question": "Compared to a full Field of View (FOV) CBCT, a limited FOV CBCT unit typically offers:",
    "options": ["A larger voxel size", "A wider diameter", "Higher resolution and greater utility for endodontics", "A higher radiation dose"],
    "answer": "Higher resolution and greater utility for endodontics",
    "images": [],
    "explanation": "Limited FOV CBCT typically uses a smaller voxel size (0.1–0.2 mm) compared to full FOV. A smaller voxel size leads to higher spatial resolution, making the limited FOV ideal for detailed endodontic diagnosis and planning.",
    "answerImage": null,
    "category": ["CBCT Basics"]
  },
  // --- NEW THEORETICAL QUESTIONS ---
  {
    "question": "What is the critical consideration that must be balanced against the potential benefits of using Cone Beam Computed Tomography (CBCT) compared to conventional dental imaging?",
    "options": ["The speed of image acquisition.", "The comparatively higher risk from radiation exposure.", "The reduced geometric distortion in 3D images.", "The cost-effectiveness of the imaging technology."],
    "answer": "The comparatively higher risk from radiation exposure.",
    "images": [],
    "explanation": "The potential health benefits gained from the superior diagnostic information provided by CBCT must always be weighed against the increased effective radiation dose to the patient.",
    "answerImage": null,
    "category": ["CBCT Basics", "Dosimetry"]
  },
  
  {
    "question": "For the diagnosis and management of endodontic problems, why is only a small Field of View (FOV) CBCT scan recommended?",
    "options": ["It is the only FOV that can utilize Metal Artifact Reduction (MAR) software.", "It reduces scatter and enhances image quality necessary for root canal intricacies.", "It is mandated by the American Association of Endodontists for legal purposes.", "It allows for faster image acquisition compared to medium FOV scans."],
    "answer": "It reduces scatter and enhances image quality necessary for root canal intricacies.",
    "images": [],
    "explanation": "A small FOV is recommended because it reduces the volume of exposed tissue and scatter, which improves image quality and provides the exceptionally high detail required for endodontic diagnostics.",
    "answerImage": null,
    "category": ["Endodontics", "CBCT Basics"]
  },
  {
    "question": "Studies on the diagnostic accuracy of CBCT for assessing root-filled teeth have indicated that approximately what percentage of histologically healthy roots may be misclassified as diseased?",
    "options": ["5%", "20%", "47%", "75%"],
    "answer": "20%",
    "images": [],
    "explanation": "Kruse et al. observed that approximately 20% of roots with confirmed healthy periapical tissues (with canal fillings) were misclassified as diseased in CBCT scans. This finding suggests that CBCT's accuracy could be diminished for root-filled teeth compared to untreated teeth.",
    "answerImage": null,
    "category": ["CBCT Limitations", "Diagnostics"]
  }
];

// Utility function to shuffle an array (Fisher-Yates algorithm)
const shuffleArray = (array) => {
  // IMPORTANT: Create a fresh copy to prevent mutating the original array
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// --- MODAL COMPONENT (Reused for Zoom) ---
const ZoomModal = ({ imageUrl, onClose }) => {
    return (
        <div 
            className="fixed inset-0 z-50 bg-black bg-opacity-80 flex items-center justify-center p-4 transition-opacity duration-300 ease-in-out cursor-zoom-out"
            onClick={onClose}
        >
            <div
                onClick={(e) => e.stopPropagation()} 
                className="max-w-4xl max-h-full bg-white rounded-xl shadow-2xl p-2 relative transform transition-transform duration-300 ease-in-out"
            >
                <img 
                    src={imageUrl} 
                    alt="Zoomed Question" 
                    className="w-full h-full object-contain max-h-[90vh] rounded-lg"
                    loading="lazy"
                    onError={(e) => { e.target.src = "https://placehold.co/400x250/ef4444/ffffff?text=Image+Load+Error"; }}
                />
                <button 
                    onClick={onClose}
                    className="absolute top-2 right-2 p-2 bg-white rounded-full text-gray-800 hover:text-red-500 transition-colors shadow-lg focus:outline-none"
                    aria-label="Close image zoom"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
        </div>
    );
};

// --- MAIN APP COMPONENT ---
const App = () => {
  // Firebase state
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [isSubscriber, setIsSubscriber] = useState(false); // Key Paywall State
  
  // Quiz state
  const [currentScreen, setCurrentScreen] = useState('start');
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [score, setScore] = useState(0);
  const [selectedOption, setSelectedOption] = useState(null);
  const [feedback, setFeedback] = useState('');
  const [explanation, setExplanation] = useState('');
  const [shuffledQuestions, setShuffledQuestions] = useState([]); 
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [currentImageIndex, setCurrentImageIndex] = useState(0); 
  const [selectedCategory, setSelectedCategory] = useState('All Categories');
  const [userAnswers, setUserAnswers] = useState([]); 

  // --- FIREBASE INITIALIZATION AND AUTH ---
  useEffect(() => {
    try {
      // Clean the appId just in case the provided environment variable includes extra path segments
      const fullAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
      const cleanAppId = fullAppId.split('/')[0]; // Use only the first segment as the true appId

      const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
      const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
      
      if (!firebaseConfig || Object.keys(firebaseConfig).length === 0) {
        console.error("Firebase config not found.");
        return;
      }

      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const userAuth = getAuth(app);
      
      setDb(firestore);
      setAuth(userAuth);

      const handleSignIn = async () => {
        try {
          if (initialAuthToken) {
            await signInWithCustomToken(userAuth, initialAuthToken);
          } else {
            await signInAnonymously(userAuth);
          }
        } catch (error) {
          console.error("Firebase Auth Error:", error);
          // Fallback to anonymous if custom token fails
          await signInAnonymously(userAuth);
        }
      };
      
      handleSignIn();

      onAuthStateChanged(userAuth, (user) => {
        if (user) {
          setUserId(user.uid);
          setIsAuthReady(true);
        } else {
          setUserId(null);
          setIsAuthReady(true);
        }
      });
    } catch (e) {
      console.error("Failed to initialize Firebase:", e);
    }
  }, []);
  
  // --- FIREBASE SUBSCRIPTION STATUS LISTENER ---
  useEffect(() => {
    if (db && userId) {
        // Corrected: Clean the appId just in case the provided environment variable includes extra path segments
        const fullAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const cleanAppId = fullAppId.split('/')[0];
        
        // Path to store user subscription status: /artifacts/{cleanAppId}/users/{userId}/profile/status
        const userStatusRef = doc(db, `artifacts/${cleanAppId}/users/${userId}/profile/status`);

        // Real-time listener for the subscription status
        const unsubscribe = onSnapshot(userStatusRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                setIsSubscriber(!!data.paid);
            } else {
                // User document doesn't exist, assume not paid
                setIsSubscriber(false);
                // Create the user profile doc if it doesn't exist (simulating initial user creation)
                setDoc(userStatusRef, { paid: false, created: new Date().toISOString() }, { merge: true }).catch(console.error);
            }
        }, (error) => {
            console.error("Error listening to subscription status:", error);
        });

        return () => unsubscribe();
    }
  }, [db, userId]);

  // Function to simulate a successful purchase (for demo)
  const handleSimulatePurchase = async () => {
      if (!db || !userId) {
          console.error("User not authenticated for purchase simulation.");
          return;
      }
      
      const fullAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
      const cleanAppId = fullAppId.split('/')[0];
      const userStatusRef = doc(db, `artifacts/${cleanAppId}/users/${userId}/profile/status`);
      
      try {
          // In a real app, this would be triggered by Stripe/PayPal success hook
          await setDoc(userStatusRef, { paid: true, last_paid: new Date().toISOString() }, { merge: true });
          console.log("Subscription status updated to PAID (Simulated).");
      } catch (error) {
          console.error("Failed to simulate purchase:", error);
      }
  };


  // --- QUIZ LOGIC FUNCTIONS ---
  
  // Free sample questions (first N questions)
  const freeQuestions = useMemo(() => quizData.slice(0, FREE_QUESTION_COUNT), []);

  // Dynamically generate the list of available categories
  const availableCategories = useMemo(() => {
    const categories = new Set(quizData.flatMap(q => q.category));
    return ['All Categories', ...Array.from(categories)];
  }, []);

  const totalQuestionsInFilter = selectedCategory === 'All Categories' 
                                 ? quizData.length 
                                 : quizData.filter(q => q.category.includes(selectedCategory)).length;

  // Handler for starting the FULL quiz (Subscriber only)
  const handleStartQuiz = () => {
    if (!isSubscriber) return; 

    let questionsToUse = quizData;
    
    if (selectedCategory !== 'All Categories') {
        questionsToUse = quizData.filter(q => q.category.includes(selectedCategory));
    }

    if (questionsToUse.length === 0) {
        return; 
    }
    
    // Shuffle is called unconditionally to ensure randomization always occurs
    const newShuffledQuestions = shuffleArray(questionsToUse);
    
    setShuffledQuestions(newShuffledQuestions);
    setUserAnswers([]); 
    setCurrentScreen('quiz');
    setCurrentQuestionIndex(0);
    setScore(0);
    setCurrentImageIndex(0); 
    setSelectedOption(null);
    setFeedback('');
    setExplanation('');
    setIsModalOpen(false);
  };
  
  // NEW Handler for starting the SAMPLE quiz (Everyone)
  const handleStartSampleQuiz = () => {
      if (freeQuestions.length === 0) return;
      
      // Shuffle is called unconditionally to ensure randomization always occurs
      const newShuffledQuestions = shuffleArray(freeQuestions);

      setShuffledQuestions(newShuffledQuestions);
      setUserAnswers([]); 
      setCurrentScreen('quiz');
      setCurrentQuestionIndex(0);
      setScore(0);
      setCurrentImageIndex(0); 
      setSelectedOption(null);
      setFeedback('');
      setExplanation('');
      setIsModalOpen(false);
      setSelectedCategory('Sample'); // Use a distinct category name for the header
  };

  const handleNextQuestion = () => {
    if (currentQuestionIndex < shuffledQuestions.length - 1) {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
      setCurrentImageIndex(0); 
      setSelectedOption(null);
      setFeedback('');
      setExplanation('');
    } else {
      setCurrentScreen('results');
    }
  };
  
  const handleTerminateQuiz = () => {
    setCurrentScreen('results');
  };

  const handleOptionClick = (option) => {
    if (selectedOption !== null || shuffledQuestions.length === 0) return;
    
    const currentQuestion = shuffledQuestions[currentQuestionIndex];
    const isCorrect = option === currentQuestion.answer;
    
    setSelectedOption(option);
    setFeedback(isCorrect ? 'Correct!' : 'Incorrect!');
    setExplanation(currentQuestion.explanation);
    
    setUserAnswers(prevAnswers => [
        ...prevAnswers,
        {
            ...currentQuestion,
            userSelection: option,
            isCorrect: isCorrect,
            questionIndex: currentQuestionIndex + 1
        }
    ]);
    
    if (isCorrect) {
      setScore(score + 1);
    }
  };
  
  const handleImageClick = () => {
    const currentImages = shuffledQuestions[currentQuestionIndex]?.images;
    if (currentImages && currentImages.length > 0) {
        setIsModalOpen(true);
    }
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
  };

  const handlePrevImage = () => {
    const currentImages = shuffledQuestions[currentQuestionIndex].images;
    setCurrentImageIndex((prevIndex) => 
      prevIndex === 0 ? currentImages.length - 1 : prevIndex - 1
    );
  };

  const handleNextImage = () => {
    const currentImages = shuffledQuestions[currentQuestionIndex].images;
    setCurrentImageIndex((prevIndex) => 
      prevIndex === currentImages.length - 1 ? 0 : prevIndex + 1
    );
  };

  // Helper component for the Quiz Title/Progress
  const QuizHeader = ({ title, current, total }) => {
    const progress = (current / total) * 100;
    return (
        <div className={`p-4 ${COLOR_PRIMARY} ${COLOR_PRIMARY_TEXT} rounded-t-3xl shadow-lg`}>
            <h1 className="text-xl font-bold text-center mb-2">{title}</h1>
            <div className="text-sm text-center mb-1">
                Question {current + 1} of {total}
            </div>
            {/* Progress bar track uses a lighter shade of the primary color */}
            <div className="w-full bg-blue-500 rounded-full h-2">
                <div 
                    className={`${COLOR_ACCENT} h-2 rounded-full transition-all duration-500 ease-out`} 
                    style={{ width: `${progress}%` }}
                ></div>
            </div>
        </div>
    );
  };
  
  // Helper component for the Paywall / Start Screen
  const renderStartScreen = () => {
    // If not authenticated yet, show loading
    if (!isAuthReady) {
        return (
             <div className="flex justify-center items-center h-48">
                <p className="text-lg text-gray-500">Loading secure features...</p>
             </div>
        );
    }
      
    // If authenticated but NOT a subscriber, show the Paywall AND Sample Option
    if (!isSubscriber) {
        return (
            <div className="flex flex-col items-center justify-center p-8 space-y-6 text-center">
                <div className="p-4 rounded-full bg-blue-100 text-blue-600">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                    </svg>
                </div>
                <h1 className="text-3xl font-extrabold text-gray-900">Unlock Full Access</h1>
                <p className="text-lg text-gray-600">This professional quiz content is reserved for paid subscribers.</p>
                <p className="text-sm text-gray-500">Your User ID (for reference): **{userId}**</p>
                
                <button
                    onClick={handleSimulatePurchase} // In a real app, this redirects to your payment provider (Stripe, PayPal)
                    className={`w-full px-8 py-4 ${COLOR_ACCENT} ${COLOR_ACCENT_TEXT} font-bold text-lg rounded-full shadow-lg ${COLOR_ACCENT_HOVER} transition-colors duration-300`}
                >
                    Subscribe Now (Simulated Purchase)
                </button>
                <p className="text-xs text-gray-400">Your current status will update immediately after payment.</p>
                
                {/* --- FREE SAMPLE QUIZ OPTION --- */}
                {freeQuestions.length > 0 && (
                    <div className="pt-4 border-t w-full mt-6">
                         <p className="text-md text-gray-700 mb-3 font-semibold">Try before you buy:</p>
                         <button
                            onClick={handleStartSampleQuiz}
                            className={`w-full px-8 py-4 ${COLOR_PRIMARY} ${COLOR_PRIMARY_TEXT} font-bold text-lg rounded-full shadow-lg ${COLOR_PRIMARY_HOVER} transition-colors duration-300`}
                        >
                            Start Free Sample ({FREE_QUESTION_COUNT} Questions)
                        </button>
                    </div>
                )}
            </div>
        );
    }
    
    // If Authenticated AND a subscriber, show the Full Start Screen
    return (
        <div
            className="flex flex-col items-center justify-center p-8 space-y-6 transition-opacity duration-300"
        >
            {/* THIS IS THE MAIN TITLE YOU NEED TO CHANGE */}
            <h1 className="text-3xl font-extrabold text-gray-900 leading-tight text-center">CBCT in Endodontics Mastery Quiz</h1>
            <p className="text-lg text-gray-600 text-center">Welcome back, Subscriber! Choose a focus area or select 'All Categories' for a mixed quiz.</p>

            {/* Category Selection Buttons */}
            <div className="flex flex-wrap justify-center gap-3">
                {availableCategories.map(category => (
                    <button
                        key={category}
                        onClick={() => setSelectedCategory(category)}
                        className={`px-4 py-2 rounded-full font-semibold transition-colors duration-200 shadow-md
                            ${selectedCategory === category
                                ? `${COLOR_PRIMARY} ${COLOR_PRIMARY_TEXT}`
                                : 'bg-gray-200 text-gray-800 hover:bg-gray-300'
                            }
                        `}
                    >
                        {category}
                    </button>
                ))}
            </div>
            
            <button
              onClick={handleStartQuiz}
              disabled={totalQuestionsInFilter === 0}
              className={`w-full px-8 py-4 mt-6 font-bold text-lg rounded-full shadow-lg transition-colors duration-300
                  ${totalQuestionsInFilter === 0 
                      ? 'bg-gray-400 text-gray-700 cursor-not-allowed'
                      : `${COLOR_ACCENT} ${COLOR_ACCENT_TEXT} ${COLOR_ACCENT_HOVER}`
                  }
              `}
            >
              Start Quiz ({selectedCategory} - {totalQuestionsInFilter} Questions)
            </button>
            {totalQuestionsInFilter === 0 && (
                <p className="text-red-500 text-sm">No questions available in this category.</p>
            )}
        </div>
    );
  };
  
  const renderReviewMode = () => {
      // ... (Review mode code remains the same as before) ...
      return (
          <div className="p-6 border-t border-gray-200">
              <h3 className="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Review Your Answers ({userAnswers.length} Attempted)</h3>
              <div className="space-y-6 max-h-96 overflow-y-auto pr-2">
                  {userAnswers.map((item, index) => (
                      <div key={index} className="p-4 bg-gray-50 rounded-lg shadow-sm border-l-4" style={{ borderColor: item.isCorrect ? '#14B8A6' : '#EF4444' }}> {/* #14B8A6 is teal-500 */}
                          <p className="font-semibold text-lg text-gray-700 mb-2">Q{item.questionIndex}: {item.question}</p>
                          
                          {/* Image Thumbnail for Review (optional) */}
                          {item.images && item.images.length > 0 && (
                            <img 
                                src={item.images[0]} 
                                alt="Question visual thumbnail" 
                                className="w-20 h-20 object-cover rounded float-right ml-4"
                                loading="lazy"
                                onError={(e) => { e.target.src = "https://placehold.co/80x80/ef4444/ffffff?text=X"; }}
                            />
                          )}

                          <p className="text-sm font-medium text-gray-600">Your Answer: 
                              <span className={`font-bold ml-1 ${item.isCorrect ? 'text-teal-600' : 'text-red-600'}`}>
                                  {item.userSelection}
                              </span>
                          </p>
                          {!item.isCorrect && (
                              <p className="text-sm font-medium text-gray-600">Correct Answer: 
                                  <span className="font-bold ml-1 text-teal-600">
                                      {item.answer}
                                  </span>
                              </p>
                          )}
                          
                          <details className="mt-2 text-sm text-gray-700 cursor-pointer">
                              <summary className="font-semibold text-blue-600 hover:text-blue-800 transition-colors">
                                  View Explanation
                              </summary>
                              <p className="pt-2">{item.explanation}</p>
                              {item.answerImage && (
                                  <img 
                                      src={item.answerImage} 
                                      alt="Answer detail" 
                                      className="mt-3 w-full max-w-xs object-contain rounded shadow-md"
                                      loading="lazy"
                                      onError={(e) => { e.target.src = "https://placehold.co/300x100/ef4444/ffffff?text=Image+Load+Error"; }}
                                  />
                              )}
                          </details>
                      </div>
                  ))}
              </div>
          </div>
      );
  };


  const renderScreen = () => {
    
    switch (currentScreen) {
      case 'start':
        return renderStartScreen();

      case 'quiz':
        if (shuffledQuestions.length === 0) return null; 

        const question = shuffledQuestions[currentQuestionIndex];
        const isAnswered = selectedOption !== null;
        const isLastQuestion = currentQuestionIndex === shuffledQuestions.length - 1;
        const currentImages = question.images;
        const activeImageUrl = currentImages[currentImageIndex];
        const answerImage = question.answerImage;
        const totalQuestions = shuffledQuestions.length;
        
        return (
          <>
            <QuizHeader 
                title={selectedCategory === 'Sample' ? 'Free Sample Quiz' : selectedCategory !== 'All Categories' ? `${selectedCategory} Quiz` : 'Mixed Quiz'} 
                current={currentQuestionIndex}
                total={totalQuestions} 
            />
            <div
              key={currentQuestionIndex}
              className="flex flex-col p-8 space-y-6 transition-opacity duration-300"
            >
              
              {/* Image Carousel / Gallery */}
              <div className="relative flex justify-center mb-4 min-h-[12rem]">
                <div 
                  className="w-full max-h-60 rounded-lg shadow-md transition-shadow hover:shadow-xl cursor-zoom-in overflow-hidden bg-gray-200 flex items-center justify-center"
                  onClick={handleImageClick}
                  aria-label="Click to zoom in on image"
                >
                  <img 
                      key={currentImageIndex}
                      src={activeImageUrl} 
                      alt={`Question Image ${currentImageIndex + 1}`} 
                      className="w-full h-full object-contain transition-opacity duration-300"
                      loading="lazy"
                      onError={(e) => { e.target.src = "https://placehold.co/400x250/ef4444/ffffff?text=Image+Load+Error"; }}
                  />
                </div>

                {/* Navigation Arrows (Only show if multiple images exist) */}
                {currentImages && currentImages.length > 1 && (
                  <>
                    <button 
                      onClick={(e) => { e.stopPropagation(); handlePrevImage(); }} 
                      className="absolute left-0 top-1/2 -translate-y-1/2 bg-white bg-opacity-70 hover:bg-opacity-90 p-2 ml-1 rounded-full shadow-lg text-gray-800 transition-colors"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" />
                      </svg>
                    </button>
                    <button 
                      onClick={(e) => { e.stopPropagation(); handleNextImage(); }} 
                      className="absolute right-0 top-1/2 -translate-y-1/2 bg-white bg-opacity-70 hover:bg-opacity-90 p-2 mr-1 rounded-full shadow-lg text-gray-800 transition-colors"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" />
                      </svg>
                    </button>
                  </>
                )}
              </div>

              {/* Image Indicator Dots (Only show if multiple images exist) */}
              {currentImages && currentImages.length > 1 && (
                <div className="flex justify-center space-x-2 mb-4">
                  {currentImages.map((_, index) => (
                    <button
                      key={index}
                      onClick={() => setCurrentImageIndex(index)}
                      className={`h-2 w-2 rounded-full transition-all duration-300 ${
                        index === currentImageIndex ? 'bg-blue-600 w-4' : 'bg-gray-300'
                      }`}
                      aria-label={`Go to image ${index + 1}`}
                    />
                  ))}
                </div>
              )}
              {/* End Image Carousel / Gallery */}


              <p className="text-xl font-bold text-gray-700 text-center min-h-[3rem]">{question.question}</p>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {question.options.map((option) => (
                  <button
                    key={option}
                    onClick={() => handleOptionClick(option)}
                    disabled={isAnswered}
                    className={`w-full px-6 py-3 rounded-xl font-medium transition-all duration-300 shadow-md hover:shadow-lg
                      ${isAnswered && (option === question.answer)
                        ? `${COLOR_ACCENT} ${COLOR_ACCENT_TEXT}` // Correct answer after selection
                        : isAnswered && (selectedOption === option && option !== question.answer)
                        ? `${COLOR_ERROR} ${COLOR_PRIMARY_TEXT}` // User's incorrect selection
                        : 'bg-gray-200 hover:bg-gray-300 text-gray-800' // Default state
                      }
                      ${isAnswered ? 'cursor-not-allowed' : 'cursor-pointer'}
                    `}
                  >
                    {option}
                  </button>
                ))}
              </div>

              {/* Explanation and Feedback Display */}
              {feedback && (
                <div
                  key={`feedback-${currentQuestionIndex}`}
                  className="text-center min-h-[4rem] space-y-2 mt-4 transition-opacity duration-300 opacity-100"
                >
                  {/* Display Answer Image if available */}
                  {answerImage && (
                      <img
                          src={answerImage}
                          alt="Answer Illustration"
                          className="mx-auto w-full max-w-xs rounded-lg shadow-md mb-3 object-contain max-h-36 transition-all duration-300"
                          loading="lazy"
                          onError={(e) => { e.target.src = "https://placehold.co/300x100/ef4444/ffffff?text=Answer+Image+Error"; }}
                      />
                  )}
                  
                  <p className={`font-bold text-lg ${feedback.startsWith('Correct') ? 'text-teal-600' : 'text-red-600'}`}>
                    {feedback}
                  </p>
                  {explanation && (
                    <p className="text-sm text-gray-700 italic px-2">
                      {explanation}
                    </p>
                  )}
                </div>
              )}

              <div className="flex space-x-4">
                  <button
                      onClick={handleTerminateQuiz}
                      className="flex-1 px-4 py-3 text-red-600 font-bold text-lg rounded-full shadow-md hover:bg-red-100 transition-colors duration-300 border border-red-300"
                  >
                      End Quiz Early
                      </button>
                  <button
                      onClick={handleNextQuestion}
                      disabled={!isAnswered}
                      className={`flex-1 px-4 py-3 font-bold text-lg rounded-full shadow-lg transition-colors duration-300
                        ${!isAnswered
                          ? 'bg-gray-400 text-gray-700 cursor-not-allowed'
                          : `${COLOR_PRIMARY} ${COLOR_PRIMARY_TEXT} ${COLOR_PRIMARY_HOVER} cursor-pointer`
                        }
                      `}
                    >
                      {isLastQuestion ? 'View Results' : 'Next Question'}
                  </button>
              </div>
            </div>
          </>
        );

      case 'results':
        const attemptedQuestions = userAnswers.length;
        const totalPossibleQuestions = shuffledQuestions.length;
        const scoreOutOfAttempted = userAnswers.filter(a => a.isCorrect).length;
        
        const percentage = attemptedQuestions > 0 ? Math.round((scoreOutOfAttempted / attemptedQuestions) * 100) : 0;
        
        const resultMessage =
          percentage === 100 && attemptedQuestions === totalPossibleQuestions
            ? "Congratulations! A perfect score!"
            : percentage >= 70
            ? "Great job! You did fantastic."
            : "You did well! Keep practicing to improve.";
            
        // Check if the quiz just completed was the sample quiz
        const justCompletedSample = selectedCategory === 'Sample';

        return (
          <div
            className="flex flex-col p-4 transition-opacity duration-300"
          >
            <div className="flex flex-col items-center justify-center p-8 space-y-4 bg-blue-50 rounded-b-3xl">
              <h1 className="text-4xl font-extrabold text-blue-700 leading-tight">Quiz Complete!</h1>
              {justCompletedSample && (
                  <p className="text-lg font-bold text-gray-800 text-center">
                      Thank you for trying our sample! Unlock the full library for advanced quizzing.
                  </p>
              )}
              <div className="text-center space-y-2">
                <p className="text-2xl font-bold text-gray-800">Your Score: {scoreOutOfAttempted} / {attemptedQuestions}</p>
                <p className="text-5xl font-extrabold text-blue-600">{percentage}%</p>
              </div>
              <p className="text-lg text-gray-600 text-center">{resultMessage}</p>
              
              {/* If completed sample, show subscribe button */}
              {justCompletedSample && (
                  <button
                    onClick={handleSimulatePurchase}
                    className={`w-full px-8 py-4 ${COLOR_ACCENT} ${COLOR_ACCENT_TEXT} font-bold text-lg rounded-full shadow-lg ${COLOR_ACCENT_HOVER} transition-colors duration-300 mt-4`}
                  >
                      Unlock All {quizData.length} Questions (Simulated)
                  </button>
              )}
              
              <button
                onClick={() => setCurrentScreen('start')}
                className={`w-full px-8 py-4 ${COLOR_PRIMARY} ${COLOR_PRIMARY_TEXT} font-bold text-lg rounded-full shadow-lg ${COLOR_PRIMARY_HOVER} transition-colors duration-300`}
              >
                {justCompletedSample ? 'Back to Paywall' : 'Start New Quiz'}
              </button>
            </div>
            
            {/* Review Mode Section */}
            {attemptedQuestions > 0 && renderReviewMode()}
          </div>
        );
      default:
        return null;
    }
  };

  const currentImageUrl = shuffledQuestions[currentQuestionIndex]?.images[currentImageIndex];

  return (
    <div className="bg-gray-100 flex items-center justify-center min-h-screen p-4 font-inter">
      <div className="bg-white rounded-3xl shadow-2xl w-full max-w-lg overflow-hidden">
        {renderScreen()}
      </div>
      
      {/* Zoom Modal Renders here, globally */}
      {isModalOpen && currentImageUrl && (
          <ZoomModal 
            imageUrl={currentImageUrl} 
            onClose={handleCloseModal} 
          />
      )}
    </div>
  );
};

export default App;
